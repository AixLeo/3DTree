<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Christmas Gift</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Caveat:wght@700&display=swap');
        body { margin: 0; overflow: hidden; background-color: #02050a; font-family: 'PingFang SC', sans-serif; }
        canvas { display: block; }
        #msg {
            position: absolute; top: 45%; width: 100%; text-align: center;
            transform: translateY(-50%); color: #fff; pointer-events: none;
            text-shadow: 0 0 20px rgba(255, 50, 80, 0.8);
            z-index: 10;
            opacity: 0; animation: fadeIn 2s forwards 1.5s;
        }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        h1 { font-family: 'Caveat', cursive; font-size: 70px; margin: 0; }
        p { font-size: 16px; letter-spacing: 4px; opacity: 0.8; }
        #timer { position: absolute; bottom: 30px; width: 100%; text-align: center; color: rgba(255,255,255,0.3); font-size: 12px; }
    </style>
</head>
<body>
    <div id="msg">
        <h1>For You</h1>
        <p>一份特别的圣诞礼物</p>
    </div>
    <div id="timer">10秒后自动返回圣诞树...</div>

    <audio id="bgMusic" loop>
    <source src="./jingle-bells.mp3" type="audio/mpeg">
    </audio>

    <canvas id="giftCanvas"></canvas>

    <script>
        const canvas = document.getElementById('giftCanvas');
        const ctx = canvas.getContext('2d');
        const music = document.getElementById('bgMusic');
        let width, height, particles = [], time = 0, rotationY = 0;
        let introProgress = 0; // 入场动画进度

        const boxSize = 70; 

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }

        // 核心：生成大小分布不均的粒子尺寸
        function getHeterogeneousSize() {
            const rand = Math.random();
            if (rand > 0.97) return Math.random() * 3 + 3.5; // 3% 特大粒子
            if (rand > 0.88) return Math.random() * 1.5 + 2.0; // 9% 中型粒子
            return Math.random() * 0.8 + 0.6; // 88% 基础小点
        }

        function createGiftBox() {
            particles = [];
            // 1. 礼物盒主体
            for (let i = 0; i < 3500; i++) {
                let x, y, z, color;
                const side = Math.floor(Math.random() * 6);
                const pos = (Math.random() - 0.5) * (boxSize * 2);
                const constant = boxSize * (Math.random() > 0.5 ? 1 : -1);
                const rand2 = (Math.random() - 0.5) * (boxSize * 2);

                if (side === 0) { x = constant; y = pos; z = rand2; }
                else if (side === 1) { x = pos; y = constant; z = rand2; }
                else { x = pos; y = rand2; z = constant; }

                if (Math.abs(x) < 15 || Math.abs(z) < 15 || (Math.abs(y) < 15 && Math.abs(x) < boxSize + 5)) {
                    color = [255, 215, 0]; // 金色丝带
                } else {
                    color = [220, 40, 60]; // 红色盒子
                }
                particles.push({ x, y, z, color, s: getHeterogeneousSize(), type: 'box' });
            }

            // 2. 蝴蝶结中心结
            for (let i = 0; i < 250; i++) {
                const phi = Math.random() * Math.PI * 2;
                const theta = Math.random() * Math.PI;
                const r = 12;
                particles.push({
                    x: r * Math.sin(theta) * Math.cos(phi),
                    y: -boxSize - 18 + r * Math.sin(theta) * Math.sin(phi),
                    z: r * Math.cos(theta),
                    color: [255, 215, 0],
                    s: getHeterogeneousSize() * 1.2,
                    type: 'bow'
                });
            }

            // 3. 蝴蝶结花瓣 (四瓣饱满结构)
            const bowCount = 1500; 
            for (let i = 0; i < bowCount; i++) {
                const angle = (i / bowCount) * Math.PI * 2;
                const r = boxSize * 0.9 * Math.abs(Math.sin(2 * angle) * Math.cos(angle)); 
                const rx = Math.cos(angle) * r;
                const rz = Math.sin(angle) * r;
                const ry = -boxSize - 18 + (Math.abs(rx) * 0.4); 

                particles.push({
                    x: rx, y: ry + (Math.random() * 6), z: rz,
                    color: [255, 235, 100],
                    s: getHeterogeneousSize() * 1.1,
                    type: 'bow'
                });
            }

            // 4. 修正后的丝带尾巴 (贴合表面，短款)
            for (let i = 0; i < 700; i++) {
                const side = i % 2 === 0 ? 1 : -1; 
                const t = Math.random(); 
                let tx, ty, tz;
                if (t < 0.5) {
                    const localT = t / 0.5;
                    tx = side * (localT * 25); 
                    ty = -boxSize - 15 + (localT * 12); 
                    tz = localT * boxSize; 
                } else if (t < 0.8) {
                    const localT = (t - 0.5) / 0.3;
                    tx = side * (25 + localT * 5); 
                    ty = -boxSize + (localT * 40); 
                    tz = boxSize + 2; 
                } else {
                    const localT = (t - 0.8) / 0.2;
                    tx = side * (30 + localT * 20);
                    ty = -boxSize + 40 + (localT * 10); 
                    tz = (boxSize + 2) + Math.sin(localT * 3) * 12; 
                }
                particles.push({ x: tx, y: ty, z: tz, color: [255, 215, 0], s: getHeterogeneousSize(), type: 'bow' });
            }
        }

        function project(x, y, z, currentRotX) {
            const rotY = rotationY;
            const rotX = currentRotX; 
            
            let x1 = x * Math.cos(rotY) - z * Math.sin(rotY);
            let z1 = x * Math.sin(rotY) + z * Math.cos(rotY);
            let y2 = y * Math.cos(rotX) - z1 * Math.sin(rotX);
            let z2 = y * Math.sin(rotX) + z1 * Math.cos(rotX);
            
            return { 
                x: x1 * 2.5 + width / 2, 
                y: y2 * 2.5 + height / 2, 
                zIndex: z2 
            };
        }

        function animate() {
            time += 0.01;
            rotationY += 0.012;

            // 入场旋转逻辑：从俯视(-1.57)平滑过渡到斜侧(-0.4)
            if (introProgress < 1) introProgress += 0.002;
            const targetRotX = -0.4;
            const startRotX = -2;
            const currentRotX = startRotX + (targetRotX - startRotX) * Math.sin(introProgress * Math.PI / 2);

            ctx.fillStyle = '#02050a';
            ctx.fillRect(0, 0, width, height);

            const rendered = particles.map(p => {
                const wave = p.type === 'box' ? Math.sin(time + p.x * 0.05) * 1.2 : Math.sin(time * 2) * 1;
                const proj = project(p.x, p.y + wave, p.z, currentRotX);
                return { ...proj, color: p.color, size: p.s };
            });

            rendered.sort((a, b) => b.zIndex - a.zIndex);

            rendered.forEach(p => {
                const brightness = (p.zIndex + boxSize) / (boxSize * 2);
                // 大粒子稍微更亮一点
                const alphaBase = p.size > 3 ? 0.7 : 0.5;
                ctx.fillStyle = `rgba(${p.color[0]},${p.color[1]},${p.color[2]},${alphaBase + brightness * 0.4})`;
                ctx.beginPath(); 
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); 
                ctx.fill();
            });
            requestAnimationFrame(animate);
        }

        window.addEventListener('load', () => {
            resize(); 
            createGiftBox(); 
            animate();

            // 音乐续播逻辑
            const savedTime = sessionStorage.getItem('musicTime');
            if (savedTime) {
                music.currentTime = parseFloat(savedTime);
            }

            // 注意：由于浏览器安全策略，页面跳转后可能需要用户点击才能继续发声
            // 但因为是从同源页面跳转且用户有过交互，大部分移动端/桌面浏览器会自动允许播放
            music.play().catch(e => {
                console.log("自动播放被拦截，等待点击触发", e);
                // 如果被拦截，可以监听整个页面的第一次点击来恢复
                window.addEventListener('pointerdown', () => music.play(), { once: true });
                window.addEventListener('touchstart', () => music.play(), { once: true });
            });

            // 10秒后返回时，同样保存进度
            setTimeout(() => {
                sessionStorage.setItem('musicTime', music.currentTime);
                sessionStorage.setItem('isMusicStarted', 'true');
                window.location.href = './index.html'; // 请确保文件名与 index 实际文件名一致
            }, 10000);
        });
        window.addEventListener('resize', resize);
    </script>
</body>
</html>
