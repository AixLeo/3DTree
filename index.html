<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Christmas Tree</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Caveat:wght@700&display=swap');

        body { margin: 0; overflow: hidden; background-color: #02050a; font-family: 'PingFang SC', sans-serif; }
        canvas { 
            display: block; 
            cursor: crosshair;
            /* 核心：阻止手机浏览器默认的缩放/滚动行为，交由 JS 处理 */
            touch-action: none; 
            -webkit-user-select: none; /* 防止长按弹出菜单 */ 
        }

        #controls {
            position: absolute; 
            bottom: 60px; 
            width: 100%; 
            text-align: center;
            color: rgb(240, 240, 238); 
            z-index: 10; 
            /* 允许点击文字 */
            pointer-events: auto; 
            cursor: pointer;
            text-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
            transition: transform 0.3s ease;
        }
        /* 鼠标悬停时的微光效果 */
        #controls:hover {
            transform: scale(1.05);
            text-shadow: 0 0 25px rgba(255, 215, 0, 0.6);
        }
        #controls h2 { 
            font-family: 'Caveat', 'Segoe Script', cursive; 
            font-size: 56px; 
            margin: 0; 
            letter-spacing: 2px; 
        }

        #overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(2, 5, 10, 0.7); 
            z-index: 100;
            display: flex; justify-content: center; align-items: center;
            color: #fff; cursor: pointer; transition: opacity 0.8s;
            backdrop-filter: blur(5px);
            font-size: 18px; letter-spacing: 2px;
            font-weight: 200;
        }
        #overlay.hidden { opacity: 0; pointer-events: none; }
        #hint { position: absolute; bottom: 40px; width: 100%; text-align: center; color: rgba(255,255,255,0.5); font-size: 14px; }
    </style>
</head>
<body>

    <div id="overlay" onclick="startExperience(false)">点击文字开启圣诞惊喜</div>
    <div id="hint">提示：点击文字有特别惊喜</div>
    <div id="controls" onclick="goToGift()">
        <h2>Merry Christmas</h2>
    </div>

<audio id="bgMusic" loop autoplay muted>
    <source src="./jingle-bells.mp3" type="audio/mpeg">
</audio>


    <canvas id="treeCanvas"></canvas>

    <script>
        const canvas = document.getElementById('treeCanvas');
        const ctx = canvas.getContext('2d');
        const music = document.getElementById('bgMusic');
        const overlay = document.getElementById('overlay');

        let treeHeightFactor;
        let width, height, particles = [], snowflakes = [], ribbons = [], fireworks = [];
        let isDragging = false, lastMouseX, lastMouseY;
        
        let rotationX = 0.8;    
        let rotationY = 0; 
        let scale = 5;        
        let time = 0;
        let isStarted = false;  
        // 新增变量用于记录手机多指缩放
        let initialPinchDistance = null;

        const targetRotationX = -0.3; 
        const targetScale = 1.2; 
        const transitionSpeed = 0.008; 

        // 跳转函数
        function goToGift() {
            if (isStarted) {
                sessionStorage.setItem('musicTime', music.currentTime); // 关键：保存当前秒数
                sessionStorage.setItem('isMusicStarted', 'true');
                window.location.href = './gift.html';
            }
        }

        // 点击交互：触发开始并产生烟花
        window.addEventListener('pointerdown', (e) => {
            if (!isStarted) {
                startExperience(false);
            }
            // 如果点击的不是文字区域，则产生烟花
            if (e.target.tagName !== 'H2' && e.target.id !== 'controls') {
                createFirework(e.clientX, e.clientY);
            }
            isDragging = true; 
            lastMouseX = e.clientX; 
            lastMouseY = e.clientY;
        });

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            // 动态计算树的高度基准：始终保持为窗口高度的 60% 到 70%
            // 这样无论窗口怎么缩，树的比例都是相对窗口对齐的
            treeHeightFactor = Math.min(height * 0.7, 500);

            // 针对不同长宽比，调整 scale 缩放系数
            if (width < height) {
                // 竖屏（手机或窄窗口）
                scale = (height / 1000) * 2.2; 
            } else {
                // 横屏（电脑全屏）
                // 增加一个动态系数，让 scale 随高度缩短而减小
                scale = (height / 800) * 1.8; 
            }

            // 关键：窗口改变时必须重新生成粒子和丝带的位置，否则它们会留在旧的坐标系里
            createParticles();
            createRibbons();
            createSnow();
            drawStar(time);
        }

        // 创建烟花
        function createFirework(x, y) {
            const count = 30;
            const colors = ['#ff5252', '#ffeb3b', '#2196f3', '#4caf50', '#ff4081', '#e040fb'];
            const color = colors[Math.floor(Math.random() * colors.length)];
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 4 + 2;
                fireworks.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 1.0,
                    decay: Math.random() * 0.02 + 0.015,
                    color: color
                });
            }
        }

        function createSnow() {
            snowflakes = [];
            for (let i = 0; i < 150; i++) {
                snowflakes.push({ 
                    x: (Math.random()-0.5)*800, 
                    y: (Math.random()-0.5)*800, 
                    z: (Math.random()-0.5)*800, 
                    s: Math.random()*2+1,
                    isRealFlake: Math.random() > 0.8 // 20% 的概率是真雪花形状
                });
            }
        }

        // 绘制真实的雪花形状
        function drawFlake(x, y, size) {
            ctx.save();
            ctx.translate(x, y);
            ctx.beginPath();
            ctx.strokeStyle = "rgba(255, 255, 255, 0.8)";
            ctx.lineWidth = 1;
            for (let i = 0; i < 6; i++) {
                ctx.moveTo(0, 0);
                ctx.lineTo(0, -size);
                ctx.moveTo(0, -size * 0.5);
                ctx.lineTo(-size * 0.3, -size * 0.8);
                ctx.moveTo(0, -size * 0.5);
                ctx.lineTo(size * 0.3, -size * 0.8);
                ctx.rotate(Math.PI / 3);
            }
            ctx.stroke();
            ctx.restore();
        }

        //生成粒子
        function createParticles() {
            particles = [];
            for (let i = 0; i < 2200; i++) {
                const h = Math.random();
                const angle = Math.random() * Math.PI * 2;
                const jitter = 1 + (Math.random() * 0.25 - 0.12);
                // const r = Math.sqrt(Math.random()) * (1 - h) * 180 * jitter;
                const r = Math.sqrt(Math.random()) * (1 - h) * (treeHeightFactor * 0.55) * jitter;
                
                let color, type = 'dot';
                const rand = Math.random();
                
                if (h > 0.9) { color = [255, 215, 0]; } 
                else if (rand > 0.8) { color = [255, 220, 50]; } 
                else if (rand > 0.65) { color = [255, 50, 80]; type = 'heart'; } 
                else { color = [45, 185, 110]; }

                particles.push({
                    baseX: Math.cos(angle) * r,
                    baseY: (1 - h) * treeHeightFactor - (treeHeightFactor / 2),
                    baseZ: Math.sin(angle) * r,
                    offset: Math.random() * Math.PI * 2,
                    size: type === 'heart' ? Math.random() * 3 + 2 : Math.random() * 1.1 + 0.5,
                    color: color,
                    type: type
                });
            }
        }

        function createRibbons() {
            ribbons = [];
            for (let i = 0; i < 6; i++) {
                const points = [];
                const startH = Math.random() * 0.5;
                const endH = startH + 0.4 + Math.random() * 0.4;
                const phase = Math.random() * Math.PI * 2;
                const rOffset = 180 + (Math.random() * 30 - 15);
                const rotSpeed = 0.3 + Math.random() * 0.4;
                
                const dashPattern = [];
                let currentPos = 0;
                while(currentPos < 60) {
                    let dashLen = Math.floor(Math.random() * 15) + 5;
                    let gapLen = Math.floor(Math.random() * 10) + 5;
                    dashPattern.push({start: currentPos, end: currentPos + dashLen});
                    currentPos += (dashLen + gapLen);
                }

                for (let j = 0; j <= 60; j++) {
                    points.push({ 
                        h: startH + (Math.min(endH, 1.0) - startH) * (j / 60), 
                        phase: phase, 
                        rOffset: rOffset, 
                        rotSpeed: rotSpeed,
                        index: j 
                    });
                }
                ribbons.push({ points, dashPattern });
            }
        }

        function project(x, y, z) {
            let x1 = x * Math.cos(rotationY) - z * Math.sin(rotationY);
            let z1 = x * Math.sin(rotationY) + z * Math.cos(rotationY);
            let y2 = y * Math.cos(rotationX) - z1 * Math.sin(rotationX);
            let z2 = y * Math.sin(rotationX) + z1 * Math.cos(rotationX);
            let p = 600 / Math.max(1, (600 + z2));
            return { x: x1 * p * scale + width / 2, y: y2 * p * scale + height / 2, s: p * scale, zIndex: z2 };
        }

        function projectStatic(x, y, z) {
            let y2 = y * Math.cos(rotationX) - z * Math.sin(rotationX);
            let z2 = y * Math.sin(rotationX) + z * Math.cos(rotationX);
            let p = 600 / Math.max(1, (600 + z2));
            return { x: x * p * scale + width / 2, y: y2 * p * scale + height / 2, s: p * scale };
        }

        function drawHeart(x, y, size) {
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.bezierCurveTo(x - size/2, y - size/2, x - size, y + size/3, x, y + size);
            ctx.bezierCurveTo(x + size, y + size/3, x + size/2, y - size/2, x, y);
            ctx.fill();
        }

        function drawStar(time) {
            const starPoints = [];
            const innerRadius = 9 * (height / 1000 + 0.5); // 星星大小也随高度微调
            const outerRadius = 24 * (height / 1000 + 0.5);
            // 星星的位置设定在树的最顶端：即树高度一半的负值再往上一点
            const starY = -(treeHeightFactor / 2) - 30;

            for (let i = 0; i < 10; i++) {
                const r = (i % 2 === 0) ? outerRadius : innerRadius;
                const angle = (i * Math.PI * 2) / 10 - Math.PI / 2;
                starPoints.push({
                    x: Math.cos(angle) * r,
                    y: starY + Math.sin(angle) * r + Math.sin(time * 3) * 4
                });
            }

            ctx.beginPath();
            ctx.shadowBlur = 25;
            ctx.shadowColor = "rgba(255, 215, 0, 1)";
            ctx.fillStyle = "rgba(255, 240, 150, 0.95)";
            
            starPoints.forEach((pt, i) => {
                const p = projectStatic(pt.x, pt.y, 0);
                if (i === 0) ctx.moveTo(p.x, p.y);
                else ctx.lineTo(p.x, p.y);
            });
            
            ctx.closePath();
            ctx.fill();
            ctx.shadowBlur = 0;
        }

        // 封装启动逻辑
        function startExperience(isAuto = false) {
            isStarted = true;
            music.muted = false;
            // 只有在非静音或用户已交互的情况下 play() 才会成功
            music.play().catch(err => console.log("播放被拦截:", err));
            overlay.classList.add('hidden');
    
            // 存入状态，下次加载此页面可识别
            sessionStorage.setItem('isMusicStarted', 'true');

            // 如果是手动点击启动的，触发一个烟花效果
            if (!isAuto) {
                // 这里的坐标可以根据需要设置，比如中心点
                createFirework(width / 2, height / 2);
                }
        }

        function animate() {
            time += 0.01;
            ctx.fillStyle = '#020510';
            ctx.fillRect(0, 0, width, height);

            if (isStarted && !isDragging) {
                if (Math.abs(rotationX - targetRotationX) > 0.001) {
                    rotationX += (targetRotationX - rotationX) * transitionSpeed;
                }
                if (Math.abs(scale - targetScale) > 0.001) {
                    scale += (targetScale - scale) * transitionSpeed;
                }
                rotationY += 0.025; 
            } else if (!isStarted) {
                rotationY += 0.001;
            }

            // 1. 雪花逻辑
            snowflakes.forEach(s => {
                s.y += 0.7; if(s.y > 400) s.y = -400;
                const p = project(s.x, s.y, s.z);
                if (s.isRealFlake) {
                    drawFlake(p.x, p.y, 4 * p.s);
                } else {
                    ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, Math.max(0, s.s * p.s), 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // 2. 绘制树顶星星
            drawStar(time);

            // 3. 丝带
            ribbons.forEach((ribbonObj, index) => {
                const { points, dashPattern } = ribbonObj;
                ctx.beginPath();
                ctx.shadowBlur = 10;
                ctx.shadowColor = "rgba(255, 215, 0, 0.3)";
                const alpha = 0.4 + Math.sin(time + index) * 0.2; 
                ctx.strokeStyle = `rgba(255, 220, 120, ${alpha})`;
                ctx.lineWidth = 1.8 * scale;

                points.forEach((pt, j) => {
                    const angle = pt.h * Math.PI * 3.5 + pt.phase + time * pt.rotSpeed;
                    const r = (1 - pt.h) * (treeHeightFactor * 0.55); // 同步半径比例
                    // 动态计算 Y 轴位置
                    const p = project(Math.cos(angle) * r, (1 - pt.h) * treeHeightFactor - (treeHeightFactor / 2), Math.sin(angle) * r);
                    const animatedIndex = (j + Math.floor(time * 20)) % 60; 
                    const isLit = dashPattern.some(d => animatedIndex >= d.start && animatedIndex <= d.end);

                    if (j === 0 || !isLit) {
                        ctx.moveTo(p.x, p.y);
                    } else {
                        ctx.lineTo(p.x, p.y);
                    }
                });
                ctx.stroke();
            });

            // 4. 树粒子
            const rendered = particles.map(p => {
                const wave = Math.sin(time * 2 + p.offset) * 2;
                const pos = project(p.baseX + wave, p.baseY, p.baseZ + wave);
                return { ...pos, color: p.color, size: p.size, type: p.type };
            });
            rendered.sort((a, b) => b.zIndex - a.zIndex);
            rendered.forEach(p => {
                const opacity = Math.max(0.1, Math.min(1, (800 - p.zIndex) / 1000));
                ctx.fillStyle = `rgba(${p.color[0]}, ${p.color[1]}, ${p.color[2]}, ${opacity})`;
                if (p.type === 'heart') {
                    drawHeart(p.x, p.y, p.size * p.s);
                } else {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, Math.max(0, p.size * p.s), 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // 5. 烟花粒子逻辑
            fireworks.forEach((f, index) => {
                f.x += f.vx;
                f.y += f.vy;
                f.vy += 0.05; // 重力
                f.life -= f.decay;
                if (f.life <= 0) {
                    fireworks.splice(index, 1);
                } else {
                    ctx.fillStyle = f.color;
                    ctx.globalAlpha = f.life;
                    ctx.beginPath();
                    ctx.arc(f.x, f.y, 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }
            });

            requestAnimationFrame(animate);
        }

        window.addEventListener('load', () => {
            resize(); 
            createParticles(); 
            createSnow(); 
            createRibbons(); 
            animate();

            // 检查是否是从 gift.html 返回（或者之前已经点过开启）
            const isBackFromGift = document.referrer.includes('gift.html');
            const hasStartedBefore = sessionStorage.getItem('isMusicStarted') === 'true';
            const savedTime = sessionStorage.getItem('musicTime');

            if (hasStartedBefore && isBackFromGift) {
                startExperience(true); // 传入 true 表示静默启动
                if (savedTime) {
                    music.currentTime = parseFloat(savedTime);
                }
            } else {
                // 首次进入，静音预备播放（处理浏览器自动播放限制）
                // 如果是直接刷新（referrer 不包含 gift.html），则重置所有状态
                sessionStorage.removeItem('isMusicStarted');
                sessionStorage.removeItem('musicTime');
                overlay.classList.remove('hidden');
                music.muted = true;
                music.play().catch(() => {});
                setTimeout(() => { music.muted = false; }, 300);
            }
        });

        // 额外保险：当页面隐藏或卸载时也保存一次
        window.addEventListener('beforeunload', () => {
            if (music && !music.muted) {
                sessionStorage.setItem('musicTime', music.currentTime);
            }
        });
        
        window.addEventListener('pointermove', (e) => {
            // 处理单指拖拽旋转
            if (isDragging && e.pointerType !== 'touch' || (isDragging && !initialPinchDistance)) {
                rotationY += (e.clientX - lastMouseX) * 0.01;
                rotationX += (e.clientY - lastMouseY) * 0.01;
                lastMouseX = e.clientX; 
                lastMouseY = e.clientY;
            }
        });
        // 处理手机端的双指缩放
        window.addEventListener('touchmove', (e) => {
            if (e.touches.length === 2) {
                isDragging = false; // 双指缩放时停止旋转
                const dist = Math.hypot(
                    e.touches[0].pageX - e.touches[1].pageX,
                    e.touches[0].pageY - e.touches[1].pageY
                );
        
                if (initialPinchDistance === null) {
                    initialPinchDistance = dist;
                } else {
                    const delta = dist / initialPinchDistance;
                    scale = Math.min(Math.max(0.2, scale * delta), 4.0);
                    initialPinchDistance = dist;
                }
            }
        }, { passive: false });

window.addEventListener('touchend', () => {
    initialPinchDistance = null;
});
        window.addEventListener('pointerup', () => isDragging = false);
        window.addEventListener('pointercancel', (e) => {
            e.preventDefault();
            scale = Math.min(Math.max(0.2, scale * (e.deltaY > 0 ? 0.9 : 1.1)), 4.0);
        }, { passive: false });
        window.addEventListener('resize', resize);
    </script>
</body>
</html>
